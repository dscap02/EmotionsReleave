Index: Metodi Pietro/Modeling.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from collections import defaultdict\r\n\r\nimport pandas as pd\r\n\r\nimport string\r\nimport asyncio\r\nimport deepl\r\nfrom nltk.corpus import stopwords\r\nfrom nltk.tokenize import word_tokenize\r\nfrom googletrans import Translator\r\nimport nltk\r\nfrom sklearn.model_selection import train_test_split\r\n\r\n#risorse nltk\r\nnltk.download('punkt')\r\nnltk.download('stopwords')\r\n\r\ndataset = pd.read_csv(\"../dataset_finale_bilanciato.csv\", sep='\\t', header=None)\r\n\r\ndataset = dataset.drop(index=0)\r\n\r\n\r\n\r\n\r\n# Separiamo la colonna in due per testo ed emozione\r\ndataset[['0', '1']] = dataset[0].str.split(',', expand=True, n=1)\r\n\r\n\r\ndataset['1'] = dataset['1'].astype(str)\r\n\r\n# Rimuoviamo la colonna originale che ora è separata\r\ndf_filtered = dataset.drop(columns=[0])\r\n\r\n\r\n# Funzione per preprocessare il testo e normalizzarlo\r\nstop_words = set(stopwords.words('english'))\r\n\r\ndef preprocess_text(text):\r\n    # Convertiamo in minuscolo\r\n    text = text.lower()\r\n    # Rimuoviamo la punteggiatura\r\n    text = text.translate(str.maketrans('', '', string.punctuation))\r\n    # Tokenizziamo il testo\r\n    words = word_tokenize(text)\r\n    # Rimuoviamo le stopwords\r\n    words = [word for word in words if word not in stop_words]\r\n    return \" \".join(words)\r\n\r\n\r\ndf_filtered['0']=df_filtered['0'].apply(preprocess_text)\r\n\r\n# Suddivisione in training set e test set\r\ntrain_set, test_set = train_test_split(df_filtered, test_size=0.2, random_state=42)\r\n\r\n\r\n\r\n\r\n# Calcolo delle frequenze nel training set\r\nemozione_counts = train_set['1'].value_counts().to_dict()\r\ntotale_messaggi = len(train_set)\r\n\r\n# Calcolo della frequenza delle parole per emozione\r\nparole_per_emozione = defaultdict(list)\r\nfor idx, row in train_set.iterrows():\r\n    parole = row['0'].split()  # Ottieni le parole preprocessate\r\n    parole_per_emozione[row['1']].extend(parole)\r\n\r\n# Calcolo della frequenza totale delle parole nel training set\r\nfrequenza_totale_parole = defaultdict(int)\r\nfor testo_normalizzato in train_set['0']:\r\n    for parola in testo_normalizzato.split():\r\n        frequenza_totale_parole[parola] += 1\r\n\r\n# Funzioni per calcolare le probabilità\r\ndef calcola_prob_emozione(emozione):\r\n    return emozione_counts.get(emozione, 0) / totale_messaggi\r\n\r\ndef calcola_prob_parola_emozione(parola, emozione):\r\n    parole = parole_per_emozione[emozione]\r\n    totale_parole = len(parole)\r\n    frequenza_parola = parole.count(parola)\r\n    return (frequenza_parola + 1) / (totale_parole + len(frequenza_totale_parole))\r\n\r\ndef calcola_prob_parola(parola):\r\n    \"\"\"P(parola): frequenza della parola nel dataset\"\"\"\r\n    totale_parole_dataset = sum(frequenza_totale_parole.values())\r\n    frequenza_parola = frequenza_totale_parole.get(parola, 0)\r\n    return frequenza_parola / totale_parole_dataset\r\n\r\n\r\ndef calcola_prob_emozione_messaggio(messaggio, emozione):\r\n    parole = messaggio.split()  # Il messaggio è già preprocessato\r\n    prob_parola_emozione = 1\r\n\r\n    # Moltiplichiamo la probabilità di ciascuna parola condizionata dall'emozione\r\n    for parola in parole:\r\n        prob_parola_emozione *= calcola_prob_parola_emozione(parola, emozione)\r\n\r\n    # Calcoliamo la probabilità della singola parola P(w_i) nel dataset\r\n    prob_parola_indipendente = 1\r\n    for parola in parole:\r\n        prob_parola_indipendente *= calcola_prob_parola(parola)\r\n\r\n    # Probabilità a priori dell'emozione\r\n    prob_emozione = calcola_prob_emozione(emozione)\r\n\r\n    # Calcoliamo la probabilità finale con il Teorema di Bayes, considerando la parola indipendente\r\n    prob_emozione_messaggio = prob_emozione * prob_parola_emozione * prob_parola_indipendente\r\n\r\n    return prob_emozione_messaggio\r\n\r\ndef predici_emozione(messaggio):\r\n    probabilita_emozioni = {\r\n        emozione: calcola_prob_emozione_messaggio(messaggio, emozione)\r\n        for emozione in emozione_counts.keys()\r\n    }\r\n    return max(probabilita_emozioni, key=probabilita_emozioni.get)\r\n\r\n# Funzione per caricare messaggi da un file di testo\r\ndef carica_test_da_file(file_path):\r\n    with open(file_path, 'r', encoding='utf-8') as file:\r\n        lines = file.readlines()\r\n    messaggi = [line.strip().split('\\t') for line in lines if line.strip()]\r\n    # Assumiamo che il file contenga: testo \\t emozione_reale\r\n    return [(preprocess_text(m[0]), m[1]) for m in messaggi]\r\n\r\n# Caricamento del file di test\r\ntest_file_path = \"test_messages.txt\"  # Inserisci il percorso al tuo file di test\r\ntest_messaggi = carica_test_da_file(test_file_path)\r\n\r\n# Calcolo delle predizioni e dell'accuratezza\r\nerrori = []\r\ntotale_test = len(test_messaggi)\r\ncorretti = 0\r\n\r\nfor messaggio, emozione_reale in test_messaggi:\r\n    predizione = predici_emozione(messaggio)\r\n    if predizione == emozione_reale:\r\n        corretti += 1\r\n    else:\r\n        errori.append({\r\n            \"messaggio\": messaggio,\r\n            \"emozione_reale\": emozione_reale,\r\n            \"emozione_predetta\": predizione\r\n        })\r\n\r\n# Risultati\r\naccuracy = corretti / totale_test\r\nprint(f\"Accuratezza finale: {accuracy:.4f}\")\r\n\r\n# Messaggi con predizioni errate\r\nprint(\"\\nMESSAGGI CON PREDIZIONI ERRATE:\")\r\nfor errore in errori:\r\n    print(f\"Messaggio: {errore['messaggio']}\")\r\n    print(f\"Emozione reale: {errore['emozione_reale']}\")\r\n    print(f\"Emozione predetta: {errore['emozione_predetta']}\")\r\n    print(\"-\" * 50)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
===================================================================
diff --git a/Metodi Pietro/Modeling.py b/Metodi Pietro/Modeling.py
--- a/Metodi Pietro/Modeling.py	(revision 00b1a49428d1d3183db78db0fd04abc6e0a30f17)
+++ b/Metodi Pietro/Modeling.py	(date 1737980049134)
@@ -59,7 +59,7 @@
 emozione_counts = train_set['1'].value_counts().to_dict()
 totale_messaggi = len(train_set)
 
-# Calcolo della frequenza delle parole per emozione
+
 parole_per_emozione = defaultdict(list)
 for idx, row in train_set.iterrows():
     parole = row['0'].split()  # Ottieni le parole preprocessate
Index: Metodi Pietro/DataPreparation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from collections import Counter\r\nfrom textblob import download_corpora\r\n\r\n\r\nimport pandas as pd\r\n\r\n\r\nfrom textblob import TextBlob\r\nfrom textblob import download_corpora\r\ndownload_corpora.download_all()\r\n\r\n\r\n# Funzione per sostituire le combinazioni 0,14 con 14\r\ndef replace_emotions(emotions):\r\n    # Converte la stringa delle emozioni in una lista di interi\r\n    emotion_list = list(map(int, emotions.split(',')))\r\n    # Se 0 e 14 sono presenti, li sostituiamo entrambi con 14\r\n    if 0 in emotion_list and 14 in emotion_list:\r\n        emotion_list = [14 if (e == 0 or e == 14) else e for e in emotion_list]\r\n    # Ritorna la lista modificata come stringa\r\n    return ','.join(map(str, sorted(emotion_list)))\r\n\r\n\r\ndef contains_correlations(emotions, correlation_set):\r\n    # Converte la stringa di emozioni in un set di interi\r\n    emotion_set = set(map(int, emotions.split(',')))\r\n    # Verifica se il set di correlazioni da eliminare è un sottoinsieme delle emozioni nella riga\r\n    return correlation_set.issubset(emotion_set)\r\n\r\n# Funzione per determinare se una riga deve essere eliminata (condizione originale)\r\ndef should_remove(emotions):\r\n    # Converte la stringa di emozioni in una lista di interi\r\n    emotion_list = list(map(int, emotions.split(',')))\r\n    # Controlla se contiene 27 e almeno un'altra emozione\r\n    return 27 in emotion_list and len(emotion_list) > 1\r\n\r\n#Funzione per controllare se le emozioni correlate sono presenti nel dataset filtrato\r\ndef contains_emotions(emotions):\r\n    # Converte la stringa delle emozioni in una lista di interi\r\n    emotion_list = list(map(int, emotions.split(',')))\r\n    # Controlla se entrambe le emozioni 0 e 24 sono presenti\r\n    return 1 in emotion_list\r\n\r\n#Funzione per determinare le istanze con una singola emozione\r\ndef has_specific_single_emotion(emotions, target_emotion):\r\n    \"\"\"\r\n    Controlla se una stringa di emozioni contiene solo una specifica emozione.\r\n\r\n    :param emotions: Una stringa contenente emozioni separate da virgola (es. \"1,24,5\").\r\n    :param target_emotion: L'emozione specifica da cercare (int).\r\n    :return: True se c'è solo l'emozione specificata, False altrimenti.\r\n    \"\"\"\r\n    # Converte la stringa delle emozioni in una lista di interi\r\n    emotion_list = list(map(int, emotions.split(',')))\r\n    # Controlla se la lista contiene solo l'emozione specificata\r\n    return len(emotion_list) == 1 and emotion_list[0] == target_emotion\r\n\r\n# Leggi il dataset\r\ndataset = pd.read_csv(\"../train.tsv\", sep='\\t', header=None)\r\n\r\n# Applica il filtro per rimuovere le righe che soddisfano la condizione originale\r\ndf_filtered = dataset[~dataset[1].apply(should_remove)]\r\n\r\n# Definisci la correlazione da eliminare\r\ncorrelation_to_remove = {0, 19}\r\n\r\n\r\n\r\n# Applica il filtro per rimuovere le righe in base alla correlazione generica\r\n#Eliminiamo le emozioni 0 e 19\r\ndf_filtered = df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\n\r\n#Eliminaimo le emozioni {0,16}\r\ncorrelation_to_remove = {0, 16}\r\ndf_filtered = df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\n\r\n#Eliminaimo le emozioni {0,12}\r\ncorrelation_to_remove = {0, 12}\r\ndf_filtered = df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\n\r\n\r\n#Accorpamento emozioni {0,14} in {14}\r\ndf_filtered[1]=df_filtered[1].apply(replace_emotions)\r\n\r\n\r\n\r\n#Eliminazione istanze emozioni correlate(Divertimento,orgoglio),perchè correlazione rara\r\n\r\ncorrelation_to_remove={1,21}\r\ndf_filtered=df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\n\r\n#dataframe per controllo presenza istanze con emozioni correlate specificate\r\ndf_with = df_filtered[df_filtered[1].apply(contains_emotions)]\r\n\r\n#print(df_with)\r\n\r\n\r\n#Eliminazione istanze emozioni correlate(Divertimento,Nervosismo),perchè correlazione rara\r\n\r\ncorrelation_to_remove={1,19}\r\ndf_filtered=df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\ndf_with=df_filtered[df_filtered[1].apply(contains_emotions)]\r\n\r\n#print(df_with)\r\n\r\n#Eliminazione istanze emozioni correlate(Divertimento,Paura),con presenza correlazione rara\r\ncorrelation_to_remove={1,14}\r\ndf_filtered=df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\ndf_with=df_filtered[df_filtered[1].apply(contains_emotions)]\r\n#print(df_with)\r\n\r\n#Eliminazione istanze emozioni correlate(Divertimento,Sollievo),con presenza correlazione rara\r\ncorrelation_to_remove={1,23}\r\ndf_filtered=df_filtered[~df_filtered[1].apply(lambda x: contains_correlations(x, correlation_to_remove))]\r\ndf_with=df_filtered[df_filtered[1].apply(contains_emotions)]\r\n#print(df_with)\r\n\r\n\r\n#Vocabolario che tiene conto di tutte le parole estratte dai messaggi con relativi indici\r\nvocabulary = {\"lol\":0,\"Lol\":1,\"funny\":2,\"haha\":3,\"fun\":4,\"Haha\":5,\"joke\":6,\"hilarious\":7,\"LOL\":8,\"laugh\":9,\"lmao\":10,\"Lmao\":11,\"Funny\":12,\"LMAO\":13,\"entertaining\":14,\"chuckle\":15,\"Fun\":16,\"JOKE\":17,\r\n\"Hilarious\":18,\"LMao\":19,\"rofl\":20,\"Chuckle\":21,\"HaHa\":22,\"amusing\":23,\"laughter\":24,\"Rofl\":25,\"Amusing\":26,\"FUN\":27,\"Joke\":28,\"Laugh\":29,\"ROFL\":30}\r\n\r\n\r\ntarget_emotion=1\r\n#Filtro istanze contenenti solo l'emozione principale(Divertimento)\r\ndf_divertimento=df_filtered[df_filtered[1].apply(lambda emotions: has_specific_single_emotion(emotions, target_emotion))]\r\n#print(df_divertimento)\r\n\r\n#Estrazione parole chiavi da istanze con emozione(Divertimento),per aggiungere e formare un set più completo\r\n#Estrazione delle parole da tutti i messaggi\r\nvocab_frequency = {word: 0 for word in vocabulary}\r\nfor text in df_divertimento[0]:\r\n    #controlliamo che siano stringhe\r\n    if not isinstance(text, str):\r\n        text = str(text)\r\n\r\n    blob = TextBlob(text.lower())\r\n    #Estrazione parole e conteggio frequenza\r\n    for word in blob.words:\r\n         if word in vocabulary:\r\n             vocab_frequency[word]+=1\r\n\r\n\r\n# Parole chiave più frequenti\r\nsorted_vocab_frequency = sorted(vocab_frequency.items(), key=lambda x: x[1], reverse=True)\r\n\r\n#Salvo tutte le parole chiavi con frequenza più alta\r\nKeywordsFrequency={}\r\nfor word, freq in sorted_vocab_frequency:\r\n    if freq > 5:\r\n        KeywordsFrequency[word]=freq\r\n\r\nKeywords={\"premura\": [\"care\", \"worry\", \"support\", \"help\", \"keep going\"]}\r\n#print(KeywordsFrequency)\r\n\r\n\r\n#filtriamo il dataset per ottenere esclusivamente le istanza con correlazione(divertimento,premura)\r\ndef contains_emotions(emotions):\r\n    # Converte la stringa delle emozioni in una lista di interi\r\n    emotion_list = list(map(int, emotions.split(',')))\r\n    # Controlla se entrambe le emozioni 1 e 5 sono presenti\r\n    return 1 in emotion_list and 5 in emotion_list\r\n\r\ndf_with=df_filtered[df_filtered[1].apply(contains_emotions)]\r\n\r\n#print(df_with)\r\n\r\n#Individuazione emozione predominante in base al conteggio delle parole chiavi relative a (divertimento,premura) e al tono e attitudine della frase\r\n\r\ndef classify_emotions_with_sentiment(text):\r\n    blob = TextBlob(text.lower())\r\n    words_premura = Keywords\r\n    words_divertimento=KeywordsFrequency\r\n\r\n    words = blob.words\r\n\r\n    count_divertimento = sum(1 for word in words if word in words_divertimento)\r\n    count_premura = sum(1 for word in words if word in words_premura)\r\n\r\n    #analizzando il tono della frase\r\n    sentiment = blob.sentiment.polarity\r\n\r\n    if count_premura > count_divertimento:\r\n        return \"premura\"\r\n    elif count_divertimento > count_premura:\r\n        return \"divertimento\"\r\n    else:\r\n        if sentiment > 0:\r\n            return \"divertimento\"  # Sentiment positivo suggerisce divertimento\r\n        elif sentiment < 0:\r\n            return \"premura\"\r\n\r\n\r\nrisultato= df_with[0].apply(\r\n    lambda text: classify_emotions_with_sentiment(text)\r\n)\r\n\r\n# Visualizza il DataFrame con l'emozione predominante\r\nprint(risultato)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
===================================================================
diff --git a/Metodi Pietro/DataPreparation.py b/Metodi Pietro/DataPreparation.py
--- a/Metodi Pietro/DataPreparation.py	(revision 00b1a49428d1d3183db78db0fd04abc6e0a30f17)
+++ b/Metodi Pietro/DataPreparation.py	(date 1737972116979)
@@ -48,6 +48,7 @@
 
     :param emotions: Una stringa contenente emozioni separate da virgola (es. "1,24,5").
     :param target_emotion: L'emozione specifica da cercare (int).
+
     :return: True se c'è solo l'emozione specificata, False altrimenti.
     """
     # Converte la stringa delle emozioni in una lista di interi
@@ -154,6 +155,7 @@
 #print(KeywordsFrequency)
 
 
+
 #filtriamo il dataset per ottenere esclusivamente le istanza con correlazione(divertimento,premura)
 def contains_emotions(emotions):
     # Converte la stringa delle emozioni in una lista di interi
Index: .idea/EmotionsReleave.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
===================================================================
diff --git a/.idea/EmotionsReleave.iml b/.idea/EmotionsReleave.iml
--- a/.idea/EmotionsReleave.iml	(revision 00b1a49428d1d3183db78db0fd04abc6e0a30f17)
+++ b/.idea/EmotionsReleave.iml	(date 1737806608554)
@@ -5,4 +5,8 @@
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
+  <component name="PyDocumentationSettings">
+    <option name="format" value="PLAIN" />
+    <option name="myDocStringFormat" value="Plain" />
+  </component>
 </module>
\ No newline at end of file
